---

- name: Install packages
  yum: name={{ item }}  state=installed
  with_items:
    - postgresql-server
    - postgresql-libs
    - postgresql-plpython
    - postgresql-contrib
    - python-psycopg2

- name: Set postgresql-server to run on boot
  service: name=postgresql enabled=yes
  ignore_errors: true
  notify:
    - restart postgresql
  tags:
    - service

- name: Initialize database
  command: service postgresql initdb creates=/var/lib/pgsql/data/postgresql.conf

- name: Add our postgres config file.  # rather than doing a `service postgresql initdb`, just copy over the 2 config files
  copy: >
    src=private/files/{{ item }}
    dest=/var/lib/pgsql/data/{{ item }}
    owner=postgres
  with_items:
    - pg_hba.conf
    - postgresql.conf
    # - pg_ident.conf
  notify:
    - restart postgresql
  tags:
    - config

- name: Ensure postgres has a place to backup to
  file: dest=/backups state=directory owner=postgres

- name: Copy over backup and pg_dump and psql restore scripts
  copy: src={{ item }} dest=/usr/local/bin/{{ item }} mode=0755
  with_items:
    - backup-database
    - restore-database

- name: Copy over backed-up database file
  # even though src is a symlink the destination will end up being a file
  copy: src=/backups/{{ item.NAME }}-latest.dump.xz dest=/backups/{{ item.NAME }}-{{ ansible_date_time.date }}.dump.xz mode=0755
  # will this fail if the playbook is run just before midnight ansible time, or is ansible_date_time a constance throughout the playbook?
  #creates: /backups/{{ item.NAME }}-{{ ansible_date_time.date }}.dump.xz
  with_items: databases

- name: Link to the backup-up database files
  shell: rm -f /backups/{{ item.NAME }}-latest.dump.xz; ln -s /backups/{{ item.NAME }}-{{ ansible_date_time.date }}.dump.xz /backups/{{ item.NAME }}-latest.dump.xz
  sudo_user: postgres
  sudo: yes
  # this will fail if the playbook is run just before midnight ansible time
  #creates: /backups/{{ item.NAME }}-latest.dump.xz
  with_items: databases

- name: Set up some cronjobs to backup databases as configured
  template: >
    src=cron-backup-database
    dest=/etc/cron.d/cron-backup-database-{{ item.NAME }}
  with_items: databases
  when: dbs_to_backup != []
  tags:
    - cron

- name: Ensure the PostgreSQL service is running
  service: name=postgresql state=restarted enabled=yes
  #"{{ postgres_sudo_user }}"
  # sudo_user: postgres 
  sudo: yes
  tags:
    - running

- name: "Ensure {{ databases | length }} databases are created"
  # sudo_user: "{{ postgres_sudo_user }}"
  # sudo_user: postgres
  # sudo: yes
  postgresql_db: name=item.NAME state=present encoding='UTF-8' lc_collate='en_US.UTF-8' lc_ctype='en_US.UTF-8'
  with_items: databases
  tags:
    - db

- name: ensure user item.USER has access to the item.NAME databases
  action: postgresql_user db=item.NAME user=item.USER password=item.PASSWORD priv=ALL state=present
  with_items: databases

- name: "Populate {{ databases | length }} databases with the latest dump (backup) file(s)"
  shell: /usr/local/bin/restore-database /backups/{{ item.NAME }}-latest.psql
  sudo_user: postgres
  sudo: yes
  with_items: databases


# # sudo usermod -a -G dev,bigdata postgres


# # - name: Ensure database is created
# #   sudo_user: "{{ postgres_sudo_user }}"
# #   postgresql_db: name={{ db_name }}
# #                  encoding='UTF-8'
# #                  lc_collate='en_US.UTF-8'
# #                  lc_ctype='en_US.UTF-8'
# #                  template='template0'
# #                  state=present

# # - name: Ensure user does not have unnecessary privileges
# #   sudo_user: "{{ postgres_sudo_user }}"
# #   postgresql_user: name={{ item.USER }}
# #                    role_attr_flags=NOSUPERUSER,NOCREATEDB
# #                    state=present
